function [ux, uy, uz] = layered_wang(xs, ys, zs, strike, dip, rake, slip, L, W, xr, yr,data_dir,count)				       				       
%[ux, uy, uz] = layered_disloc(xs, ys, zs, strike, dip, rake,
%                              slip, L, W, npw, npy, xr, yr, edks)
% --- INPUT ---
% --- SOURCE INFO
% --- 1D arrays, length = number of fault patches
% xs     m, east coord to middle of top edge of fault 
% ys     m, north coord to middle of top edge of fault 
% zs m, depth coord to middle of top edge of fault (+ down) 
% strike deg, clockwise from north 
% dip    deg, 90 is vertical 
% rake   deg, 0 strike slip, 90 dip slip 
% slip   m, slip in the rake direction
% L      m, along strike fault length 
% W      m, down dip fault length 
% npw    scalar, # point sources per patch in the down dip direction
% npy    scalar, # point sources per patch in the along strike direction
% --- RECEIVER INFO
% 1D arrays, length = number of receivers
% xr     m, east coordinate of receivers 
% yr     m, north coordinate of receivers 
% --- ELASTIC STRUCTURE INFO
% edks   string, full name of edks file, e.g., halfspace.edks
% --- OUTPUT ---
% --- 2D arrays, (receivers, fault patches)
% ux     m, east displacement
% uy     m, west displacement
% uz     m, up displacement (+ up)

% np   = length(xs); % number of patches
np = 1;
nrec = length(xr); % number of receivers
dpath = '.';

%%%%% filenames
pref = 'ridge';

fedc = fopen([dpath,'/',data_dir,'/edcmp_ridge_',num2str(count),'.inp'],'wt');

%fprintf(fedc,['#TYP   LONCEN      LATCEN       DCEN      STR' ...
%	      '       DIP       HORLEN    DIPLEN    SS(m)    DS(m)' ...
%	       '  OP(m) RAKE\n']);

fprintf(fedc,['#===============================================================================\n' ...
'# OBSERVATION ARRAY\n' ...
'# =================\n' ...
'# 1. switch for irregular positions (0) or a 1D profile (1)\n' ...
'#    or a rectangular 2D observation array (2): ixyr\n' ...
'#\n' ...
'#    IF (0 for irregular observation positions) THEN\n' ...
'#    \n' ...
'# 2. number of positions: nr\n' ...
'# 3. coordinates of the observations: (xr(i),yr(i)),i=1,nr\n' ...
'#\n' ...
'#    ELSE IF (1 for regular 2D observation array) THEN\n' ...
'#\n' ...
'# 2. number of position samples of the profile: nr\n' ...
'# 3. the start and end positions: (xr1,yr1), (xr2,yr2)\n' ...
'#\n' ...
'#    ELSE IF (2 for rectanglular 2D observation array) THEN\n' ...
'#\n' ...
'# 2. number of xr samples, start and end values [m]: nxr, xr1,xr2\n' ...
'# 3. number of yr samples, start and end values [m]: nyr, yr1,yr2\n' ...
'#\n' ...
'#    Note that the total number of observation positions (nr or nxr*nyr)\n' ...
'#    should be <= NRECMAX (see edcglobal.h)!\n' ...
'#=============================================================================== \n']);
fprintf(fedc,' 0 \n');
fprintf(fedc,' %d \n',nrec);
% for i=1:nrec
%     fprintf(fedc,' ( %e , %e ) \n',yr(i),xr(i));  % x is North in edcmp
% end 


% binary observation points file to be read into EDCMP
file_rec = [data_dir,'.rec'];

%%%%% write receiver location file (observation points)
% temp = [yr(:), xr(:)]';   % x is North in edcmp
% fid  = fopen([dpath,'/',data_dir,'/',file_rec],'w');
% fwrite(fid, temp, 'real*4');
% fclose(fid);
%%%%% included in each dataset directory

fprintf(fedc,['#===============================================================================\n' ...
'# OUTPUTS\n' ...
'# =======\n' ...
'# 1. output directory in char format: outdir\n' ...
'# 2. select the desired outputs (1/0 = yes/no)\n' ...
'# 3. the file names in char format for displacement vector, strain tensor,\n' ...
'#    stress tensor, and vertical tilts:\n' ...
'#    dispfile, strainfile, stressfile, tiltfile\n' ...
'#\n' ...
'#    Note that all file or directory names should not be longer than 80\n' ...
'#    characters. Directories must be ended by / (unix) or \\ (dos) \n' ...
'#===============================================================================\n']);
outdir=['''./',data_dir,'/outdata/''']; 
fprintf(fedc,' %s \n',outdir);
fprintf(fedc,'        1               0              0              0 \n');
fdisp=['''',pref,'.disp''']; 
fstrn=['''',pref,'.strn''']; 
fstrs=['''',pref,'.strs''']; 
ftilt=['''',pref,'.tilt''']; 
fprintf(fedc,'    %s     %s     %s     %s \n', fdisp, fstrn, fstrs, ftilt);


fprintf(fedc,['#= ========================================================================\n' ...
'# RECTANGLAR DISLOCATION SOURCES\n' ...
'# ==============================\n' ...
'# 1. number of the source rectangles: ns (<= NSMAX in edcglobal.h)\n' ...
'# 2. the 6 parameters for the 1. source rectangle:\n' ...
'#    Slip [m],\n' ...
'#    coordinates of the upper reference point for strike (xs, ys, zs) [m],\n' ...
'#    length (strike direction) [m], and width (dip direction) [m],\n' ...
'#    strike [deg], dip [deg], and rake [deg];\n' ...
'# 3. ... for the 2. source ...\n' ...
'# ...\n' ...
'#                   N\n' ...
'#                  /\n' ...
'#                 /| strike\n' ...
'#         Ref:-> @------------------------\n' ...
'#                |\\        p .            \\ W\n' ...
'#                :-\\      i .              \\ i\n' ...
'#                |  \\    l .                \\ d\n' ...
'#                :90 \\  S .                  \\ t\n' ...
'#                |-dip\\  .                    \\ h\n' ...
'#                :     \\. | rake               \\ \n' ...
'#                Z      -------------------------\n' ...
'#                              L e n g t h\n' ...
'#\n' ...
'#    Note that if one of the parameters length and width = 0, then a line source\n' ...
'#    will be considered and the displocation parameter Slip has the unit m^2; if\n' ...
'#    both length and width = 0, then a point source will be considered and the\n' ...
'#    Slip has the unit m^3.\n' ...
'# \n' ...
'#no  Slip     xs        ys       zs        length    width   strike   dip  rake\n' ...
'#===============================================================================\n']);

fprintf(fedc,' %d \n',np);
% output refernce point of each patch
yv = xs;  
xv = ys;
zv = -zs;
for i=1:np
    fprintf(fedc,'%d %9.4e %9.4e %9.4e %9.4e %7.2e %7.2e %8.4f %8.4f %5.1f \n',i,slip(i),xv(i),yv(i),zv(i),L(i),W(i),strike(i),dip(i),rake(i));
end

fprintf(fedc,['#===============================================================================\n' ...
'# CHOICE OF EARTH MODEL\n' ...
'# =====================\n' ...
'# 1. switch for layered (1) or homogeneous (0) model\n' ...
'#\n' ...
'#    IF (layered model) THEN\n' ...
'#\n' ...
'# 2. directory of the Green''s functions and the three files for the\n' ...
'#    fundamental Green''s functions: grndir, grnfiles(3);\n' ...
'#\n' ...
'#    Note that all file or directory names should not be longer than 80\n' ...
'#    characters. Directories must be ended by / (unix) or \\ (dos) \n' ...
'#\n' ...
'#    ELSE (homogeneous model) THEN\n' ...
'#\n' ...
'# 2. the observation depth, the two Lame constants parameters of the homogeneous\n' ...
'#    model: zrec [m], lambda [Pa], mu [Pa]\n' ...
'#===============================================================================\n']);

fprintf(fedc,' 1 \n');
fss=['''',pref,'.ss''']; 
fds=['''',pref,'.ds''']; 
fop=['''',pref,'.cl''']; 
fgrn='''./edgrnfcts/'''; 
fprintf(fedc,' %s   %s   %s   %s \n', fgrn, fss, fds, fop);

status = fclose(fedc);
disp(status);
			   

%%%%% call sum_layered to calculate Greens functions

comstr = ['/home4/zjin2/software/edgrn_escmp/edcmp ',data_dir,'/edcmp_ridge_',num2str(count),'.inp ',data_dir,'/',data_dir,' >& log'];
% disp(comstr);
system(comstr);

%%%%% read sum_layered output Greens function

out = load([data_dir,'/outdata/',pref,'.disp']); 
ux=out(:,5);
uy=out(:,4);
uz=-out(:,6);

end
