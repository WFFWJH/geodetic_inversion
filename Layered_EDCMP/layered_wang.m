function U = layered_wang(xs,ys,zs,strike,dip,rake,slip,L,W,NR,data_dir,green_dir,count,varargin)				       				       
%[ux, uy, uz] = layered_disloc(xs, ys, zs, strike, dip, rake,
%                              slip, L, W, npw, npy, xr, yr, edks)
% --- INPUT ---
% --- SOURCE INFO
% --- 1D arrays, length = number of fault patches
% xs     m, east coord to middle of top edge of fault 
% ys     m, north coord to middle of top edge of fault 
% zs m, depth coord to middle of top edge of fault (+ down) 
% strike deg, clockwise from north 
% dip    deg, 90 is vertical 
% rake   deg, 0 strike slip, 90 dip slip 
% slip   m, slip in the rake direction
% L      m, along strike fault length 
% W      m, down dip fault length 
% npw    scalar, # point sources per patch in the down dip direction
% npy    scalar, # point sources per patch in the along strike direction
% --- RECEIVER INFO
% 1D arrays, length = number of receivers
% xr     m, east coordinate of receivers 
% yr     m, north coordinate of receivers 
% --- ELASTIC STRUCTURE INFO
% edks   string, full name of edks file, e.g., halfspace.edks
% --- OUTPUT ---
% --- 2D arrays, (receivers, fault patches)
% ux     m, east displacement
% uy     m, west displacement
% uz     m, up displacement (+ up)

np = length(xs); % number of patches
% np = 1;
% nrec = length(xr); % number of receivers
nrec = NR;

% output file is displacement or strain or stress or tilt
out_type = 'disp';
obs_type = 0;      % default is irregular observation points
obs_arr = [];      % observation array boundaries, in format of [xr1,yr1,xr2,yr2];  
if ~isempty(varargin)
    for CC = 1:floor(length(varargin)/2)
        try
            switch lower(varargin{CC*2-1})
                case 'out_file'
                    out_type = varargin{CC*2};
                case 'obs_type'
                    obs_type = varargin{CC*2};
                case 'obs_arr'
                    obs_arr = varargin{CC*2};
            end
        catch
            error('Unrecognized Keyword');
        end
    end
end

%%%%% filenames
pref = 'ridge';
fedc = fopen([data_dir,'/edcmp_ridge',num2str(count),'.inp'],'wt');
fprintf(fedc,['#===============================================================================\n' ...
'# OBSERVATION ARRAY\n' ...
'# =================\n' ...
'# 1. switch for irregular positions (0) or a 1D profile (1)\n' ...
'#    or a rectangular 2D observation array (2): ixyr\n' ...
'#\n' ...
'#    IF (0 for irregular observation positions) THEN\n' ...
'#    \n' ...
'# 2. number of positions: nr\n' ...
'# 3. coordinates of the observations: (xr(i),yr(i)),i=1,nr\n' ...
'#\n' ...
'#    ELSE IF (1 for regular 2D observation array) THEN\n' ...
'#\n' ...
'# 2. number of position samples of the profile: nr\n' ...
'# 3. the start and end positions: (xr1,yr1), (xr2,yr2)\n' ...
'#\n' ...
'#    ELSE IF (2 for rectanglular 2D observation array) THEN\n' ...
'#\n' ...
'# 2. number of xr samples, start and end values [m]: nxr, xr1,xr2\n' ...
'# 3. number of yr samples, start and end values [m]: nyr, yr1,yr2\n' ...
'#\n' ...
'#    Note that the total number of observation positions (nr or nxr*nyr)\n' ...
'#    should be <= NRECMAX (see edcglobal.h)!\n' ...
'#=============================================================================== \n']);
fprintf(fedc,' %d \n',obs_type);
if obs_type == 0 || obs_type == 1
    fprintf(fedc,' %d \n',nrec);
    if obs_type == 1
        fprintf(fedc,'(%.2e, %.2e), (%.2e, %.2e)\n',obs_arr(2),obs_arr(1),obs_arr(4),obs_arr(3));
    end
elseif obs_type == 2
    if length(nrec) ~= 2, error('Something wrong with receiver points!'); end
    fprintf(fedc,' %d  %.2e  %.2e\n',nrec(1),obs_arr(2),obs_arr(4));
    fprintf(fedc,' %d  %.2e  %.2e\n',nrec(2),obs_arr(1),obs_arr(3));
else 
    error('There is something wrong with observation type');
end

% binary observation points file to be read into EDCMP
% file_rec = [data_dir,'.rec'];

%%%%% write receiver location file (observation points)
% temp = [yr(:), xr(:)]';   % x is North in edcmp
% fid  = fopen([dpath,'/',data_dir,'/',file_rec],'w');
% fwrite(fid, temp, 'real*4');
% fclose(fid);
%%%%% included in each dataset directory

fprintf(fedc,['#===============================================================================\n' ...
'# OUTPUTS\n' ...
'# =======\n' ...
'# 1. output directory in char format: outdir\n' ...
'# 2. select the desired outputs (1/0 = yes/no)\n' ...
'# 3. the file names in char format for displacement vector, strain tensor,\n' ...
'#    stress tensor, and vertical tilts:\n' ...
'#    dispfile, strainfile, stressfile, tiltfile\n' ...
'#\n' ...
'#    Note that all file or directory names should not be longer than 80\n' ...
'#    characters. Directories must be ended by / (unix) or \\ (dos) \n' ...
'#===============================================================================\n']);
outdir=['''',data_dir,'/outdata/''']; 
fprintf(fedc,' %s \n',outdir);
if strcmp(out_type,'disp')
   fprintf(fedc,'        1               0              0              0 \n');
elseif strcmp(out_type,'strn')
   fprintf(fedc,'        0               1              0              0 \n');
elseif strcmp(out_type,'strs')
   fprintf(fedc,'        0               0              1              0 \n');
elseif strcmp(out_type,'tilt')
   fprintf(fedc,'        0               0              0              1 \n');
else
   error('There is something wrong with output file type!');
end
fdisp=['''',pref,'.disp''']; 
fstrn=['''',pref,'.strn''']; 
fstrs=['''',pref,'.strs''']; 
ftilt=['''',pref,'.tilt''']; 
fprintf(fedc,'    %s     %s     %s     %s \n', fdisp, fstrn, fstrs, ftilt);


fprintf(fedc,['#= ========================================================================\n' ...
'# RECTANGLAR DISLOCATION SOURCES\n' ...
'# ==============================\n' ...
'# 1. number of the source rectangles: ns (<= NSMAX in edcglobal.h)\n' ...
'# 2. the 6 parameters for the 1. source rectangle:\n' ...
'#    Slip [m],\n' ...
'#    coordinates of the upper reference point for strike (xs, ys, zs) [m],\n' ...
'#    length (strike direction) [m], and width (dip direction) [m],\n' ...
'#    strike [deg], dip [deg], and rake [deg];\n' ...
'# 3. ... for the 2. source ...\n' ...
'# ...\n' ...
'#                   N\n' ...
'#                  /\n' ...
'#                 /| strike\n' ...
'#         Ref:-> @------------------------\n' ...
'#                |\\        p .            \\ W\n' ...
'#                :-\\      i .              \\ i\n' ...
'#                |  \\    l .                \\ d\n' ...
'#                :90 \\  S .                  \\ t\n' ...
'#                |-dip\\  .                    \\ h\n' ...
'#                :     \\. | rake               \\ \n' ...
'#                Z      -------------------------\n' ...`
'#                              L e n g t h\n' ...
'#\n' ...
'#    Note that if one of the parameters length and width = 0, then a line source\n' ...
'#    will be considered and the displocation parameter Slip has the unit m^2; if\n' ...
'#    both length and width = 0, then a point source will be considered and the\n' ...
'#    Slip has the unit m^3.\n' ...
'# \n' ...
'#no  Slip     xs        ys       zs        length    width   strike   dip  rake\n' ...
'#===============================================================================\n']);

fprintf(fedc,' %d \n',np);
% output refernce point of each patch
yv = xs;  
xv = ys;
zv = -zs;
for i=1:np
    fprintf(fedc,'%d %9.4e %9.4e %9.4e %9.4e %7.2e %7.2e %8.4f %8.4f %5.1f \n',i,slip(i),xv(i),yv(i),zv(i),L(i),W(i),strike(i),dip(i),rake(i));
end

fprintf(fedc,['#===============================================================================\n' ...
'# CHOICE OF EARTH MODEL\n' ...
'# =====================\n' ...
'# 1. switch for layered (1) or homogeneous (0) model\n' ...
'#\n' ...
'#    IF (layered model) THEN\n' ...
'#\n' ...
'# 2. directory of the Green''s functions and the three files for the\n' ...
'#    fundamental Green''s functions: grndir, grnfiles(3);\n' ...
'#\n' ...
'#    Note that all file or directory names should not be longer than 80\n' ...
'#    characters. Directories must be ended by / (unix) or \\ (dos) \n' ...
'#\n' ...
'#    ELSE (homogeneous model) THEN\n' ...
'#\n' ...
'# 2. the observation depth, the two Lame constants parameters of the homogeneous\n' ...
'#    model: zrec [m], lambda [Pa], mu [Pa]\n' ...
'#===============================================================================\n']);

fprintf(fedc,' 1 \n');
% fprintf(fedc,' 0 \n');
fss=['''',pref,'.ss''']; 
fds=['''',pref,'.ds''']; 
fop=['''',pref,'.cl''']; 
% fgrn='''./edgrnfcts/'''; 
fgrn = ['''',green_dir,''''];
fprintf(fedc,' %s   %s   %s   %s \n', fgrn, fss, fds, fop);
% fprintf(fedc,' 0.00d+03  3.00d+10  3.00d+10 \n');

status = fclose(fedc);
disp(status);
			   

% %%%%% call sum_layered to calculate Greens functions
% if obs_type == 0
%     comstr = ['/Users/zej011/work/software/edgrn_edcmp_2003/edcmp2.0 ',data_dir, ...
%               '/edcmp_ridge',num2str(count),'.inp ',data_dir,'/full_obs'];
% else
%     comstr = ['/Users/zej011/work/software/edgrn_edcmp_2003/edcmp2.0 ',data_dir, ...
%               '/edcmp_ridge',num2str(count),'.inp '];
% end
% disp(comstr);
% system(comstr);
% 
% output_str = ['awk ''NR>3 {print $0}'' ',data_dir,'/outdata/',pref,'.',out_type,' > ', ...
%                data_dir,'/outdata/data_only'];
% system(output_str);
% 
% %%%%% read sum_layered output Greens function
% out = load([data_dir,'/outdata/data_only']); 
% if strcmp(out_type,'disp')
%     ux = out(:,4);
%     uy = out(:,3);
%     uz = -out(:,5);
%     U = [ux,uy,uz];
% elseif strcmp(out_type,'strs')
%     Sxx = out(:,3);
%     Syy = out(:,4);
%     Szz = out(:,5);
%     Sxy = out(:,6);
%     Syz = out(:,7);
%     Szx = out(:,8);
%     U = [Sxx,Syy,Szz,Sxy,Szx,Syz];
% end
U = 0;

end
